---
layout: post
title: "October 8th - React, Mongo, & Algorithms"
---
After going through some exercises on spotting bugs in react, and fixing a non working Yahtzee game in order to function properly, we are moving on to the React Component Lifecycle.

We will be discussing what component lifecycle is; methods for mounting, updating, and unmounting; as well as less commonly used lifecycle methods.

Every component comes with methods that allow us to update application state and reflect the changes to the UI before/after key react "events". Events as in the stages or lifecycles of the component (mounting, updating, unmounting).

<!--more-->

## Life Cycle Methods

When using a component, React first calls the components `constructor()`, it is often used for initializing state or binding event handlers to class instance. Next, the `render()` method is used. It tells React what should be displayed and React updates the DOM to match it's output. The following from [projects.wojtekmaj.pl/react-lifecycle-methods-diagram](projects.wojtekmaj.pl/react-lifecycle-methods-diagram) is a diagram of what the lifecycle.

<img src="/assets/img/lifecycle-diagram.png" width="700"/>

### `ComponentDidMount()`

`componentDidMount()` is a method lifecycle that we can use and React will run it for us after the component has mounted, **after** the first time it is rendered to the DOM.

It is a good place to load any data via AJAX or set up subscriptions/timers.

Example:
```javascript
class Timer extends Component {
  constructor(props) {
    super(props)
    console.log("In Constructor")
  }

  componentDidMount(){
    console.log("In Component Did Mount")
  }

  render() {
    console.log("In Render")
    return <h1>TIMER</h1>
  }
}

// 1 -> In constructor
// 2 -> In Render
// 3 -> In Component Did Mount
```
`componentDidMount()` will only be called once. If the component re-renders, it will not be called again. Like previously stated, its best to call any timers you need or subscriptions you would need in this method. Lets look into this now.

#### Loading Data
For the following example we will use the Axios npm package to retrieve data from a simple API.

```javascript
import axios from 'axios';

class ZenQuote extends Component {
  constructor(props) {
    super(props)
    this.state = {quote: ''}
  }
  componentDidMount() {
    axios.get("https://api.gitub/com/zen").then(response => {
      this.setState({quote: response.data})
    })
  }
  render() {
    return (
      <div>
        <h1>{`Always remember...${this.state.quote}`}</h1>
      </div>
    )
  }
}
```

Why can't we do this in the constructor, instead of `componentDidMount()`. It is specified NOT TO by React, so, don't do it.

Something to be aware of is that since the code inside of `componentDidMount()` wont be running until after the first render, there will be a visible delay between what is rendered, and what data is retrieved and stored.

Adding `async` in front of `componentDidMount()` will allow you to use javascript's `async/await` functionality, not requiring `.then` or other methods we normally need to use outside of `async` functions.

#### Adding Animated Loaders
To do this, we can keep track of 'loading' in state. We can use conditional rendering to render either a loading animation or the data, based on the current state of the app. Pretty straightforward.

### `componentDidUpdate()`
When state changes, props change, or an update is forced (`forceUpdate()`) we can use the `componentDidUpdate()` lifecycle method to run some code. It is called every time the DOM is rendered AFTER the first time it is rendered after `componentDidMount()` is run.

#### Accessing prevProps and prevState
Inside of this lifecycle method, we have access to the previous props and previous state in order to do a comparison between the previous and current state and props. To get this, we pass these like so in the method:
```javascript
componentDidUpdate(prevProps, prevState) {
  // you can call setState here as well if needed
}
```
### `componentWillUnmount()`
This is invoked immediately before a component is unmounted (removed from page). React Docs state that we can perform any necessary cleanup in this method, like canceling timers, network requests, or any subscriptions that were created in `componentDidMount()`. Calling `setState()` here is useless because there will be no re-rendering after this.

## MongoDB
We will start off with an exercise to solidify some of yesterday's learning about CRUD operations in the shell.

### Inserting Records
```
use patientData
db.patientData.insertMany([
  {"firstName" : "Jordan", "lastName":"Vidrine", "age": 32, "history" : [{"illness":"cold"}]},
  {"firstName" : "Donald", "lastName":"Duck", "age": 64, "history" : [{"illness":"arrogance"}]},
  {"firstName" : "Hill", "lastName":"Billy", "age": 72, "history" : [{"illness":"amnesia"}]},
  ])
```

### Updating Records / Inserting into an array of documents
We can use the `$addToSet:` operator to add information to an array of documents. This will add the document if it is not currently in the array.
```
db.patientData.updateOne({"firstName":"Jordan"},{$addToSet: {"history": {"disease":"tumor", "treatment":"surgery"}}})
```

### Find info by query
The following would get all patients over the age of 45
```
db.patientData.find({"age":{$gt:45}})
```

### Deleting by query
The following would delete all patients who have had a "cold" in their array of diseases and treatments.
```
db.deleteMany({"history.disease": "cold"})
```

### Deleting a Database
This is really simple. Type in `use [database name]` then `db.dropDatabase()`. Be sure you really want to do this, as there is no turning back!
